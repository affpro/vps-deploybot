name: Configure Nginx Service
description: "Create or update nginx configuration for a specific service with individual config files. Supports subdomain and path-based routing."

inputs:
  host:
    description: "VPS hostname or IP"
    required: true
  user:
    description: "SSH username"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  service_name:
    description: "Name of the service (used for config file naming)"
    required: true
  container_name:
    description: "Name of the Docker container to proxy to"
    required: true
  container_port:
    description: "Internal port the container is running on"
    required: true
  routing_type:
    description: "Type of routing: 'subdomain' or 'path'"
    required: false
    default: "subdomain"
  server_name:
    description: "Server name for subdomain routing (e.g., api.example.com)"
    required: false
    default: ""
  path_prefix:
    description: "Path prefix for path-based routing (e.g., /api)"
    required: false
    default: ""
  domain:
    description: "Main domain for path-based routing (e.g., example.com)"
    required: false
    default: ""
  nginx_container_name:
    description: "Name of the nginx container"
    required: false
    default: "nginx_proxy"
  remove_service:
    description: "Set to true to remove the service configuration"
    required: false
    default: "false"
  enable_ssl:
    description: "Enable SSL/HTTPS configuration"
    required: false
    default: "false"
  ssl_cert_path:
    description: "Path to SSL certificate file"
    required: false
    default: ""
  ssl_key_path:
    description: "Path to SSL private key file"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Configure Service
      shell: bash
      env:
        SERVICE_NAME: "${{ inputs.service_name }}"
        CONTAINER_NAME: "${{ inputs.container_name }}"
        CONTAINER_PORT: "${{ inputs.container_port }}"
        ROUTING_TYPE: "${{ inputs.routing_type }}"
        SERVER_NAME: "${{ inputs.server_name }}"
        PATH_PREFIX: "${{ inputs.path_prefix }}"
        DOMAIN: "${{ inputs.domain }}"
        NGINX_CONTAINER: "${{ inputs.nginx_container_name }}"
        REMOVE_SERVICE: "${{ inputs.remove_service }}"
        ENABLE_SSL: "${{ inputs.enable_ssl }}"
        SSL_CERT_PATH: "${{ inputs.ssl_cert_path }}"
        SSL_KEY_PATH: "${{ inputs.ssl_key_path }}"
      run: |
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "SERVICE_NAME='$SERVICE_NAME' CONTAINER_NAME='$CONTAINER_NAME' CONTAINER_PORT='$CONTAINER_PORT' ROUTING_TYPE='$ROUTING_TYPE' SERVER_NAME='$SERVER_NAME' PATH_PREFIX='$PATH_PREFIX' DOMAIN='$DOMAIN' NGINX_CONTAINER='$NGINX_CONTAINER' REMOVE_SERVICE='$REMOVE_SERVICE' ENABLE_SSL='$ENABLE_SSL' SSL_CERT_PATH='$SSL_CERT_PATH' SSL_KEY_PATH='$SSL_KEY_PATH' bash -s" <<-'EOF'
          set -euo pipefail

          NGINX_SITES_DIR="/opt/nginx/sites-enabled"
          CONFIG_FILE="$NGINX_SITES_DIR/service-$SERVICE_NAME.conf"

          echo "ðŸ”§ Configuring nginx for service: $SERVICE_NAME"

          # Validate inputs
          if [ -z "$SERVICE_NAME" ] || [ -z "$CONTAINER_NAME" ] || [ -z "$CONTAINER_PORT" ]; then
            echo "âŒ Missing required parameters: service_name, container_name, and container_port are required"
            exit 1
          fi

          # Check if nginx container exists
          if ! sudo docker ps --format '{{.Names}}' | grep -q "^${NGINX_CONTAINER}$"; then
            echo "âŒ Nginx container '$NGINX_CONTAINER' not found. Please run setup-vps-nginx first."
            exit 1
          fi

          # Handle service removal
          if [ "$REMOVE_SERVICE" = "true" ]; then
            echo "ðŸ—‘ Removing service configuration: $SERVICE_NAME"
            if [ -f "$CONFIG_FILE" ]; then
              sudo rm "$CONFIG_FILE"
              echo "âœ… Removed configuration file: $CONFIG_FILE"
            else
              echo "âš ï¸ Configuration file not found: $CONFIG_FILE"
            fi

            # Reload nginx
            echo "ðŸ”„ Reloading nginx configuration..."
            if sudo docker exec "$NGINX_CONTAINER" nginx -s reload; then
              echo "âœ… Nginx reloaded successfully"
            else
              echo "âŒ Failed to reload nginx"
              exit 1
            fi

            echo "ðŸŽ‰ Service '$SERVICE_NAME' removed successfully!"
            exit 0
          fi

          # Validate routing configuration
          if [ "$ROUTING_TYPE" = "subdomain" ]; then
            if [ -z "$SERVER_NAME" ]; then
              echo "âŒ server_name is required for subdomain routing"
              exit 1
            fi
            FINAL_SERVER_NAME="$SERVER_NAME"
            FINAL_LOCATION="/"
            PROXY_PASS_PATH=""
          elif [ "$ROUTING_TYPE" = "path" ]; then
            if [ -z "$PATH_PREFIX" ] || [ -z "$DOMAIN" ]; then
              echo "âŒ path_prefix and domain are required for path-based routing"
              exit 1
            fi
            FINAL_SERVER_NAME="$DOMAIN"
            FINAL_LOCATION="$PATH_PREFIX"
            # Remove trailing slash from container path
            PROXY_PASS_PATH="/"
          else
            echo "âŒ Invalid routing_type: $ROUTING_TYPE (must be 'subdomain' or 'path')"
            exit 1
          fi

          echo "ðŸ“ Creating nginx configuration for '$SERVICE_NAME'..."
          echo "   Type: $ROUTING_TYPE"
          echo "   Container: $CONTAINER_NAME:$CONTAINER_PORT"
          echo "   Server: $FINAL_SERVER_NAME"
          echo "   Location: $FINAL_LOCATION"

          # Ensure directory exists and is writable
          echo "ðŸ“ Checking nginx configuration directory..."
          sudo mkdir -p "$NGINX_SITES_DIR"
          sudo chmod 755 "$NGINX_SITES_DIR"
          echo "   Directory: $NGINX_SITES_DIR"
          sudo ls -ld "$NGINX_SITES_DIR"

          # Create the configuration file using cat with proper variable expansion
          echo "ðŸ“ Generating HTTP server configuration..."
          echo "   Output file: $CONFIG_FILE"
          sudo bash -c "cat > $CONFIG_FILE" <<SHELLEOF
# Service: $SERVICE_NAME
server {
    listen 80;
    server_name $FINAL_SERVER_NAME;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";

    # Let's Encrypt ACME challenge
    location /.well-known/acme-challenge/ {
        root /var/www/acme-challenges;
        try_files \\\$uri =404;
    }

    location $FINAL_LOCATION {
        set \\\$backend_upstream http://$CONTAINER_NAME:$CONTAINER_PORT;
        proxy_pass \\\$backend_upstream$PROXY_PASS_PATH;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \\\$http_upgrade;
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \\\$scheme;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
}
SHELLEOF

          # Add health check location for path-based routing (only in HTTP server)
          if [ "$ROUTING_TYPE" = "path" ]; then
            echo "ðŸ“ Adding health check location..."
            sudo bash -c "cat >> $CONFIG_FILE" <<'HEALTHEOF'
    location ${PATH_PREFIX}/health {
        set $backend_upstream http://${CONTAINER_NAME}:${CONTAINER_PORT};
        proxy_pass $backend_upstream/health;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        access_log off;
    }
}
HEALTHEOF
          fi

          # Add SSL configuration if enabled
          echo "ðŸ” SSL Configuration Check:"
          echo "   ENABLE_SSL=$ENABLE_SSL"
          echo "   SSL_CERT_PATH=$SSL_CERT_PATH"
          echo "   SSL_KEY_PATH=$SSL_KEY_PATH"

          if [ "$ENABLE_SSL" = "true" ] && [ -n "$SSL_CERT_PATH" ] && [ -n "$SSL_KEY_PATH" ]; then
            # Verify SSL certificate files exist before adding configuration
            if ! sudo test -f "$SSL_CERT_PATH"; then
              echo "âš ï¸  SSL certificate file not found: $SSL_CERT_PATH"
              echo "   Skipping SSL configuration. Certificate must be provisioned first."
              echo "   Hint: Use setup-vps-letsencrypt action to provision certificates."
              ENABLE_SSL="false"
            elif ! sudo test -f "$SSL_KEY_PATH"; then
              echo "âš ï¸  SSL private key file not found: $SSL_KEY_PATH"
              echo "   Skipping SSL configuration. Certificate must be provisioned first."
              echo "   Hint: Use setup-vps-letsencrypt action to provision certificates."
              ENABLE_SSL="false"
            fi
          else
            echo "âš ï¸  SSL configuration disabled (enable_ssl=false or paths empty)"
            ENABLE_SSL="false"
          fi

          if [ "$ENABLE_SSL" = "true" ] && [ -n "$SSL_CERT_PATH" ] && [ -n "$SSL_KEY_PATH" ]; then
            echo "âœ… SSL is enabled and certificate paths are provided"
            # Append HTTPS server block
            sudo bash -c "cat >> $CONFIG_FILE" <<SSLEOF
server {
    listen 443 ssl;
    http2 on;
    server_name $FINAL_SERVER_NAME;
    ssl_certificate $SSL_CERT_PATH;
    ssl_certificate_key $SSL_KEY_PATH;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Let's Encrypt ACME challenge
    location /.well-known/acme-challenge/ {
        root /var/www/acme-challenges;
        try_files \\\$uri =404;
    }

    location $FINAL_LOCATION {
        set \\\$backend_upstream http://$CONTAINER_NAME:$CONTAINER_PORT;
        proxy_pass \\\$backend_upstream$PROXY_PASS_PATH;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \\\$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass \\\$http_upgrade;
        proxy_set_header Host \\\$host;
        proxy_set_header X-Real-IP \\\$remote_addr;
        proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }
SSLEOF

            # Add SSL health check for path-based routing
            if [ "$ROUTING_TYPE" = "path" ]; then
              sudo bash -c "cat >> $CONFIG_FILE" <<'SSLHEALTHEOF'
    location ${PATH_PREFIX}/health {
        set $backend_upstream http://${CONTAINER_NAME}:${CONTAINER_PORT};
        proxy_pass $backend_upstream/health;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        access_log off;
    }
}
SSLHEALTHEOF
            else
              # Close HTTPS server block (when not doing path-based routing)
              echo "}" | sudo tee -a "$CONFIG_FILE" > /dev/null
            fi
          else
            # Close HTTP server block only (no SSL)
            # Already closed in the initial HTTP block generation
            true
          fi

          # Verify the configuration file was created properly
          echo "âœ… Configuration file created: $CONFIG_FILE"
          echo "ðŸ“Š File verification:"
          echo "   Size: $(sudo wc -c < "$CONFIG_FILE") bytes"
          echo "   Lines: $(sudo wc -l < "$CONFIG_FILE") lines"
          echo "   First 10 lines:"
          sudo head -10 "$CONFIG_FILE" | sed 's/^/     /'

          # Test nginx configuration
          echo "ðŸ” Testing nginx configuration..."
          if sudo docker exec "$NGINX_CONTAINER" nginx -t; then
            echo "âœ… Nginx configuration test passed"
          else
            echo "âŒ Nginx configuration test failed. Removing invalid config..."
            sudo rm "$CONFIG_FILE"
            exit 1
          fi

          # Reload nginx
          echo "ðŸ”„ Reloading nginx configuration..."
          if sudo docker exec "$NGINX_CONTAINER" nginx -s reload; then
            echo "âœ… Nginx reloaded successfully"
          else
            echo "âŒ Failed to reload nginx. Rolling back..."
            sudo rm "$CONFIG_FILE"
            exit 1
          fi

          echo "ðŸŽ‰ Service '$SERVICE_NAME' configured successfully!"
          echo ""
          echo "ðŸ“‹ Service Details:"
          echo "   Service: $SERVICE_NAME"
          echo "   Container: $CONTAINER_NAME:$CONTAINER_PORT"
          echo "   Routing: $ROUTING_TYPE"
          if [ "$ROUTING_TYPE" = "subdomain" ]; then
            echo "   URL: http://$SERVER_NAME"
            if [ "$ENABLE_SSL" = "true" ]; then
              echo "   HTTPS URL: https://$SERVER_NAME"
            fi
          else
            echo "   URL: http://$DOMAIN$PATH_PREFIX"
            if [ "$ENABLE_SSL" = "true" ]; then
              echo "   HTTPS URL: https://$DOMAIN$PATH_PREFIX"
            fi
          fi
          echo "   Config file: $CONFIG_FILE"
        EOF

    - name: Verify Service Configuration
      shell: bash
      env:
        SERVICE_NAME: "${{ inputs.service_name }}"
        NGINX_CONTAINER: "${{ inputs.nginx_container_name }}"
        REMOVE_SERVICE: "${{ inputs.remove_service }}"
      run: |
        if [ "$REMOVE_SERVICE" = "true" ]; then
          echo "â„¹ï¸ Service removal completed, skipping verification"
          exit 0
        fi

        echo "ðŸ” Verifying service configuration..."
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "SERVICE_NAME='$SERVICE_NAME' NGINX_CONTAINER='$NGINX_CONTAINER' bash -s" <<-'EOF'
          set -euo pipefail

          CONFIG_FILE="/opt/nginx/sites-enabled/service-$SERVICE_NAME.conf"

          # Check if config file exists
          if [ -f "$CONFIG_FILE" ]; then
            echo "âœ… Configuration file exists: $CONFIG_FILE"
            echo "ðŸ“„ File size: $(stat -f%z "$CONFIG_FILE" 2>/dev/null || stat -c%s "$CONFIG_FILE" 2>/dev/null) bytes"
          else
            echo "âŒ Configuration file not found: $CONFIG_FILE"
            exit 1
          fi

          # Check nginx status
          echo "ðŸ“Š Nginx container status:"
          sudo docker ps --filter "name=$NGINX_CONTAINER" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || echo "Container not found"

          # Show recent nginx logs
          echo "ðŸ“ Recent nginx logs:"
          sudo docker logs --tail=5 "$NGINX_CONTAINER" 2>/dev/null || echo "Could not fetch logs"

          # List all active service configurations
          echo "ðŸ“‹ Active service configurations:"
          ls -la /opt/nginx/sites-enabled/service-*.conf 2>/dev/null || echo "No service configurations found"

          echo "âœ… Verification completed!"
        EOF