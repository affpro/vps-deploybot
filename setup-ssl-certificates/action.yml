name: Setup SSL Certificates
description: "Generate and manage SSL/TLS certificates using Let's Encrypt certbot. Supports both wildcard (DNS-01) and individual (HTTP-01) certificates."

inputs:
  host:
    description: "VPS hostname or IP"
    required: true
  user:
    description: "SSH username"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  cert_type:
    description: "Certificate type: 'wildcard' or 'individual'"
    required: true
  domain:
    description: "Primary domain (e.g., taxi-laguna.com)"
    required: true
  subdomains:
    description: "Comma-separated subdomains for individual certs (e.g., api,admin,www). Not needed for wildcard."
    required: false
    default: ""
  email:
    description: "Email address for Let's Encrypt notifications"
    required: true
  challenge_type:
    description: "Challenge type: 'dns' or 'http'. Use 'dns' for wildcard certs."
    required: false
    default: "dns"
  webroot_path:
    description: "Webroot path for HTTP-01 challenge"
    required: false
    default: "/var/www/certbot"
  nginx_container_name:
    description: "Name of the nginx container to reload after cert generation"
    required: false
    default: "nginx_proxy"
  staging:
    description: "Use Let's Encrypt staging server for testing (avoids rate limits)"
    required: false
    default: "false"
  skip_if_exists:
    description: "Skip certificate generation if valid certificate already exists"
    required: false
    default: "true"
  force_renewal:
    description: "Force certificate renewal even if not near expiry"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Install Certbot
      shell: bash
      env:
        CHALLENGE_TYPE: "${{ inputs.challenge_type }}"
      run: |
        echo "üì¶ Installing certbot on VPS..."
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "CHALLENGE_TYPE='$CHALLENGE_TYPE' bash -s" <<-'EOF'
          set -euo pipefail

          echo "üîç Checking if certbot is installed..."
          if command -v certbot &> /dev/null; then
            echo "‚úÖ Certbot already installed: $(certbot --version)"
          else
            echo "üì• Installing certbot..."
            sudo apt-get update -qq
            sudo apt-get install -y certbot
            echo "‚úÖ Certbot installed: $(certbot --version)"
          fi

          # Create webroot directory for HTTP-01 challenge if needed
          if [ "$CHALLENGE_TYPE" = "http" ]; then
            echo "üìÅ Creating webroot directory for HTTP-01 challenge..."
            sudo mkdir -p /var/www/certbot
            sudo chmod 755 /var/www/certbot
          fi
        EOF

    - name: Generate Certificate
      shell: bash
      env:
        CERT_TYPE: "${{ inputs.cert_type }}"
        DOMAIN: "${{ inputs.domain }}"
        SUBDOMAINS: "${{ inputs.subdomains }}"
        EMAIL: "${{ inputs.email }}"
        CHALLENGE_TYPE: "${{ inputs.challenge_type }}"
        WEBROOT_PATH: "${{ inputs.webroot_path }}"
        STAGING: "${{ inputs.staging }}"
        SKIP_IF_EXISTS: "${{ inputs.skip_if_exists }}"
        FORCE_RENEWAL: "${{ inputs.force_renewal }}"
      run: |
        echo "üîê Checking SSL certificate status..."
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "CERT_TYPE='$CERT_TYPE' DOMAIN='$DOMAIN' SUBDOMAINS='$SUBDOMAINS' EMAIL='$EMAIL' CHALLENGE_TYPE='$CHALLENGE_TYPE' WEBROOT_PATH='$WEBROOT_PATH' STAGING='$STAGING' SKIP_IF_EXISTS='$SKIP_IF_EXISTS' FORCE_RENEWAL='$FORCE_RENEWAL' bash -s" <<-'EOF'
          set -euo pipefail

          STAGING_FLAG=""
          if [ "$STAGING" = "true" ]; then
            STAGING_FLAG="--staging"
            echo "‚ö†Ô∏è  Using Let's Encrypt staging server (certificates won't be trusted)"
          fi

          # Build domain arguments
          DOMAIN_ARGS="-d $DOMAIN"

          if [ "$CERT_TYPE" = "wildcard" ]; then
            echo "üåê Generating wildcard certificate for *.$DOMAIN"
            DOMAIN_ARGS="$DOMAIN_ARGS -d *.$DOMAIN"

            if [ "$CHALLENGE_TYPE" != "dns" ]; then
              echo "‚ö†Ô∏è  Wildcard certificates require DNS-01 challenge. Switching to DNS challenge."
              CHALLENGE_TYPE="dns"
            fi
          elif [ "$CERT_TYPE" = "individual" ]; then
            if [ -z "$SUBDOMAINS" ]; then
              echo "‚ùå subdomains parameter required for individual certificate type"
              exit 1
            fi

            echo "üìã Generating individual certificate for: $DOMAIN and subdomains"
            IFS=',' read -ra SUBDOMAIN_ARRAY <<< "$SUBDOMAINS"
            for subdomain in "${SUBDOMAIN_ARRAY[@]}"; do
              subdomain=$(echo "$subdomain" | xargs)  # trim whitespace
              if [ -n "$subdomain" ]; then
                DOMAIN_ARGS="$DOMAIN_ARGS -d ${subdomain}.${DOMAIN}"
                echo "   - ${subdomain}.${DOMAIN}"
              fi
            done
          else
            echo "‚ùå Invalid cert_type: $CERT_TYPE (must be 'wildcard' or 'individual')"
            exit 1
          fi

          # Check if certificate already exists
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN"
          if [ -d "$CERT_PATH" ]; then
            echo "‚úÖ Certificate already exists at $CERT_PATH"
            echo ""
            echo "üìÖ Certificate details:"
            sudo certbot certificates -d "$DOMAIN" 2>/dev/null || true
            echo ""

            # Check certificate expiry
            CERT_FILE="$CERT_PATH/cert.pem"
            if [ -f "$CERT_FILE" ]; then
              EXPIRY_DATE=$(sudo openssl x509 -enddate -noout -in "$CERT_FILE" | cut -d= -f2)
              EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s 2>/dev/null || date -j -f "%b %d %T %Y %Z" "$EXPIRY_DATE" +%s 2>/dev/null)
              CURRENT_EPOCH=$(date +%s)
              DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))

              echo "üìä Certificate expires in $DAYS_UNTIL_EXPIRY days"

              # Skip if certificate is valid and not near expiry
              if [ "$SKIP_IF_EXISTS" = "true" ] && [ "$FORCE_RENEWAL" != "true" ] && [ $DAYS_UNTIL_EXPIRY -gt 30 ]; then
                echo "‚úÖ Certificate is valid and not near expiry (>30 days). Skipping generation."
                echo "üí° Use force_renewal: true to renew anyway"
                exit 0
              fi

              # Auto-renew if near expiry or force renewal
              if [ "$FORCE_RENEWAL" = "true" ] || [ $DAYS_UNTIL_EXPIRY -le 30 ]; then
                if [ "$FORCE_RENEWAL" = "true" ]; then
                  echo "üîÑ Force renewal requested"
                else
                  echo "‚ö†Ô∏è  Certificate expires in $DAYS_UNTIL_EXPIRY days, proceeding with renewal"
                fi
              fi
            fi
          else
            echo "üìù No existing certificate found, generating new certificate..."
          fi

          # Generate certificate based on challenge type
          if [ "$CHALLENGE_TYPE" = "dns" ]; then
            echo ""
            echo "üîê Starting DNS-01 challenge for certificate generation..."
            echo "‚ö†Ô∏è  IMPORTANT: You will need to add DNS TXT records manually"
            echo ""

            sudo certbot certonly \
              --manual \
              --preferred-challenges dns \
              --email "$EMAIL" \
              --agree-tos \
              --no-eff-email \
              $STAGING_FLAG \
              $DOMAIN_ARGS

          elif [ "$CHALLENGE_TYPE" = "http" ]; then
            echo "üåê Starting HTTP-01 challenge..."

            if [ ! -d "$WEBROOT_PATH" ]; then
              echo "‚ùå Webroot path does not exist: $WEBROOT_PATH"
              exit 1
            fi

            sudo certbot certonly \
              --webroot \
              -w "$WEBROOT_PATH" \
              --email "$EMAIL" \
              --agree-tos \
              --no-eff-email \
              --non-interactive \
              $STAGING_FLAG \
              $DOMAIN_ARGS
          else
            echo "‚ùå Invalid challenge_type: $CHALLENGE_TYPE (must be 'dns' or 'http')"
            exit 1
          fi

          if [ $? -eq 0 ]; then
            echo ""
            echo "‚úÖ Certificate generated successfully!"
            echo ""
            echo "üìã Certificate details:"
            sudo certbot certificates -d "$DOMAIN"
            echo ""
            echo "üìÅ Certificate files location:"
            echo "   Cert: /etc/letsencrypt/live/$DOMAIN/fullchain.pem"
            echo "   Key:  /etc/letsencrypt/live/$DOMAIN/privkey.pem"
          else
            echo "‚ùå Certificate generation failed"
            exit 1
          fi
        EOF

    - name: Setup Auto-Renewal
      shell: bash
      env:
        NGINX_CONTAINER: "${{ inputs.nginx_container_name }}"
        DOMAIN: "${{ inputs.domain }}"
      run: |
        echo "üîÑ Setting up certificate auto-renewal..."
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "NGINX_CONTAINER='$NGINX_CONTAINER' DOMAIN='$DOMAIN' bash -s" <<-'EOF'
          set -euo pipefail

          # Create renewal hook script
          HOOK_SCRIPT="/etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh"
          echo "üìù Creating renewal hook script..."

          sudo mkdir -p /etc/letsencrypt/renewal-hooks/deploy

          # Create hook script using echo to avoid nested heredoc issues
          sudo bash -c "echo '#!/bin/bash' > $HOOK_SCRIPT"
          sudo bash -c "echo '# Reload nginx container after certificate renewal' >> $HOOK_SCRIPT"
          sudo bash -c "echo 'if docker ps --format '\"'\"'{{.Names}}'\"'\"' | grep -q \"^nginx_proxy\$\"; then' >> $HOOK_SCRIPT"
          sudo bash -c "echo '  echo \"üîÑ Reloading nginx after certificate renewal...\"' >> $HOOK_SCRIPT"
          sudo bash -c "echo '  docker exec nginx_proxy nginx -s reload' >> $HOOK_SCRIPT"
          sudo bash -c "echo '  echo \"‚úÖ Nginx reloaded successfully\"' >> $HOOK_SCRIPT"
          sudo bash -c "echo 'else' >> $HOOK_SCRIPT"
          sudo bash -c "echo '  echo \"‚ö†Ô∏è  Nginx container not found, skipping reload\"' >> $HOOK_SCRIPT"
          sudo bash -c "echo 'fi' >> $HOOK_SCRIPT"

          sudo chmod +x "$HOOK_SCRIPT"
          echo "‚úÖ Renewal hook created: $HOOK_SCRIPT"

          # Test certbot renewal (dry run)
          echo "üß™ Testing certificate renewal (dry run)..."
          if sudo certbot renew --dry-run --cert-name "$DOMAIN"; then
            echo "‚úÖ Renewal test passed"
          else
            echo "‚ö†Ô∏è  Renewal test failed, but certificate is still valid"
          fi

          # Check systemd timer status
          echo ""
          echo "üìä Certbot renewal timer status:"
          sudo systemctl status certbot.timer --no-pager || echo "‚ö†Ô∏è  Certbot timer not found (will use cron)"

          echo ""
          echo "‚úÖ Auto-renewal configured!"
          echo "‚ÑπÔ∏è  Certificates will auto-renew via systemd timer or cron"
        EOF

    - name: Display Certificate Info
      shell: bash
      env:
        DOMAIN: "${{ inputs.domain }}"
        NGINX_CONTAINER: "${{ inputs.nginx_container_name }}"
      run: |
        echo "üìã Certificate setup completed!"
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "DOMAIN='$DOMAIN' NGINX_CONTAINER='$NGINX_CONTAINER' bash -s" <<-'EOF'
          set -euo pipefail

          echo ""
          echo "üéâ SSL Certificate Setup Complete!"
          echo ""
          echo "üìÅ Certificate paths for nginx configuration:"
          echo "   ssl_certificate:     /etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          echo "   ssl_certificate_key: /etc/letsencrypt/live/$DOMAIN/privkey.pem"
          echo ""
          echo "üí° Next steps:"
          echo "   1. Mount certificates into nginx container:"
          echo "      -v /etc/letsencrypt:/etc/nginx/letsencrypt:ro"
          echo ""
          echo "   2. Use configure-nginx-service action with SSL enabled:"
          echo "      enable_ssl: true"
          echo "      ssl_cert_path: /etc/nginx/letsencrypt/live/$DOMAIN/fullchain.pem"
          echo "      ssl_key_path: /etc/nginx/letsencrypt/live/$DOMAIN/privkey.pem"
          echo ""
          echo "   3. Verify renewal timer is active:"
          echo "      sudo systemctl status certbot.timer"
        EOF
