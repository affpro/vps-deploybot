name: Deploy Docker Image to VPS
description: "Transfer Docker image archive to VPS and deploy as container with zero-downtime deployment"

inputs:
  host:
    description: "VPS hostname or IP"
    required: true
  user:
    description: "SSH username"
    required: true
  private_key:
    description: "SSH private key content"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  image_archive:
    description: "Path to the Docker image archive file (e.g., 'app.tar.gz')"
    required: true
  container_name:
    description: "Name for the Docker container"
    required: true
  docker_run_args:
    description: "Additional arguments for docker run command (ports, env vars, volumes, etc.)"
    required: false
    default: ""
  startup_commands:
    description: "Startup commands as JSON array (e.g., '[\"echo Starting...\", \"yarn cli:prod migration:run\"]')"
    required: false
    default: "[]"
  main_command:
    description: "Main command to keep container running (e.g., 'node ./dist/server.js')"
    required: true
  health_check_url:
    description: "URL to check container health after deployment (optional)"
    required: false
    default: ""
  health_check_timeout:
    description: "Timeout in seconds for health check"
    required: false
    default: "60"

runs:
  using: "composite"
  steps:
    - name: Setup SSH Key and Connection
      shell: bash
      run: |
        mkdir -p ~/.ssh && chmod 700 ~/.ssh
        printf '%s' "${{ inputs.private_key }}" | tr -d '\r' > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H -p "${{ inputs.port }}" "${{ inputs.host }}" 2>/dev/null >> ~/.ssh/known_hosts || true

    - name: Transfer Docker Image to VPS
      shell: bash
      run: |
        echo "üìÅ Creating docker-images directory on VPS..."
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" -o StrictHostKeyChecking=no \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "mkdir -p ~/docker-images"

        echo "üì¶ Transferring Docker image to VPS..."
        scp -i ~/.ssh/id_rsa -P "${{ inputs.port }}" -o StrictHostKeyChecking=no \
          "${{ inputs.image_archive }}" \
          "${{ inputs.user }}@${{ inputs.host }}:~/docker-images/"

    - name: Deploy Docker Container
      shell: bash
      env:
        IMAGE_ARCHIVE: "${{ inputs.image_archive }}"
        CONTAINER_NAME: "${{ inputs.container_name }}"
        DOCKER_RUN_ARGS: "${{ inputs.docker_run_args }}"
        STARTUP_COMMANDS: "${{ inputs.startup_commands }}"
        MAIN_COMMAND: "${{ inputs.main_command }}"
      run: |
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "IMAGE_ARCHIVE='$IMAGE_ARCHIVE' CONTAINER_NAME='$CONTAINER_NAME' DOCKER_RUN_ARGS='$DOCKER_RUN_ARGS' STARTUP_COMMANDS='$STARTUP_COMMANDS' MAIN_COMMAND='$MAIN_COMMAND' bash -s" << 'EOF'
          set -euo pipefail

          echo "üöÄ Starting Docker deployment process..."

          # Ensure docker-images directory exists
          mkdir -p ~/docker-images
          cd ~/docker-images

          # Extract image name from archive
          IMAGE_NAME=$(echo "$IMAGE_ARCHIVE" | sed 's/\.tar\.gz$//')

          echo "üì¶ Loading Docker image from archive..."
          sudo docker load < "$IMAGE_ARCHIVE"

          # Stop and remove existing container if it exists
          if sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo "üõë Stopping existing container: $CONTAINER_NAME"
            sudo docker stop "$CONTAINER_NAME" || true
            echo "üóë Removing existing container: $CONTAINER_NAME"
            sudo docker rm "$CONTAINER_NAME" || true
          fi

          # Clean up old images (keep latest)
          echo "üßπ Cleaning up old Docker images..."
          sudo docker images "$IMAGE_NAME" --format "table {{.ID}}\t{{.CreatedAt}}" | \
            tail -n +2 | head -n -1 | awk '{print $1}' | \
            xargs -r sudo docker rmi || true

          # Debug: Test image first
          echo "üîç Testing image before running container..."
          echo "Image inspection:"
          sudo docker run --rm "$IMAGE_NAME:latest" echo "Image test successful" || echo "Image test failed"
          echo "Shell test:"
          sudo docker run --rm "$IMAGE_NAME:latest" /bin/sh -c "echo Shell works" || echo "Shell test failed"
          echo "Working directory:"
          sudo docker run --rm "$IMAGE_NAME:latest" pwd || echo "PWD failed"
          echo "File listing:"
          sudo docker run --rm "$IMAGE_NAME:latest" ls -la || echo "LS failed"

          # Build container command
          echo "üîÑ Starting new container: $CONTAINER_NAME"
          echo "Using docker run args: $DOCKER_RUN_ARGS"

          # Build startup script from JSON array
          STARTUP_SCRIPT=""
          if [ "$STARTUP_COMMANDS" != "[]" ] && [ -n "$STARTUP_COMMANDS" ]; then
            echo "üìã Startup commands:"
            # Parse JSON array into bash array
            readarray -t STARTUP_COMMANDS_ARRAY < <(echo "$STARTUP_COMMANDS" | jq -r '.[]')

            # Build startup script
            for cmd in "${STARTUP_COMMANDS_ARRAY[@]}"; do
              echo "  ‚Üí $cmd"
              STARTUP_SCRIPT="$STARTUP_SCRIPT$cmd && "
            done
          fi

          # Run new container with startup commands
          FULL_COMMAND="$STARTUP_SCRIPT$MAIN_COMMAND"
          echo "üöÄ Full command: $FULL_COMMAND"

          # Use default bridge network (same as PostgreSQL)
          echo "üåê Using default bridge network for container communication..."

          # Verify postgres_container is accessible on bridge network
          if sudo docker network inspect bridge --format '{{range .Containers}}{{.Name}}{{end}}' | grep -q "postgres_container"; then
            echo "‚úÖ postgres_container found on bridge network"
          else
            echo "‚ö†Ô∏è postgres_container not found on bridge network, connecting it..."
            sudo docker network connect bridge postgres_container 2>/dev/null || echo "Already connected or failed"
          fi

          sudo docker run -d --name "$CONTAINER_NAME" --network bridge $DOCKER_RUN_ARGS "$IMAGE_NAME:latest" sh -c "$FULL_COMMAND"

          # Verify container is running and monitor startup
          echo "‚è≥ Waiting for container to start..."
          for i in $(seq 1 60); do
            container_status=$(sudo docker inspect -f '{{.State.Status}}' "$CONTAINER_NAME" 2>/dev/null || echo "none")
            if [ "$container_status" = "running" ]; then
              echo "‚úÖ Container $CONTAINER_NAME is running"
              break
            elif [ "$container_status" = "exited" ]; then
              echo "‚ùå Container exited unexpectedly. Logs:"
              sudo docker logs --tail=50 "$CONTAINER_NAME" || true
              exit 1
            fi
            echo "üîÑ Waiting for container... ($i/60) Status: $container_status"

            # Show logs if container is restarting frequently
            if [ "$container_status" = "restarting" ] && [ $((i % 10)) -eq 0 ]; then
              echo "üîç Container restarting frequently, showing recent logs:"
              sudo docker logs --tail=20 "$CONTAINER_NAME" || true
            fi

            sleep 2
          done

          # Show container status
          echo "üìä Container status:"
          sudo docker ps --filter "name=$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          # Show recent logs (including migration output)
          echo "üìù Container startup logs (including migrations):"
          sudo docker logs --tail=50 "$CONTAINER_NAME" || true

          # Stream logs for 30 seconds to show real-time output
          echo "üì° Streaming container logs for 30 seconds..."
          timeout 30 sudo docker logs -f "$CONTAINER_NAME" 2>/dev/null || echo "Log streaming completed"

          # Clean up the archive file
          rm -f "$IMAGE_ARCHIVE"

          echo "‚úÖ Deployment completed successfully!"
        EOF

    - name: Health Check (Optional)
      shell: bash
      if: ${{ inputs.health_check_url != '' }}
      run: |
        echo "üè• Performing health check on service endpoint..."
        HEALTH_URL="${{ inputs.health_check_url }}"
        TIMEOUT="${{ inputs.health_check_timeout }}"
        CONTAINER_NAME="${{ inputs.container_name }}"

        echo "üîç Waiting for service to complete migrations and start..."
        sleep 10  # Give time for migrations to complete

        for i in $(seq 1 $TIMEOUT); do
          echo "üîÑ Health check attempt $i/$TIMEOUT on $HEALTH_URL"

          # Try to get a response with more details
          response=$(curl -f -s -w "HTTP_CODE:%{http_code}" "$HEALTH_URL" 2>/dev/null || echo "FAILED")

          if echo "$response" | grep -q "HTTP_CODE:200"; then
            echo "‚úÖ Health check passed: $HEALTH_URL"
            echo "üìã Service response: $(echo "$response" | sed 's/HTTP_CODE:200//')"
            echo "üéâ Service is healthy and ready!"
            exit 0
          elif echo "$response" | grep -q "HTTP_CODE:"; then
            http_code=$(echo "$response" | grep -o "HTTP_CODE:[0-9]*" | cut -d: -f2)
            echo "‚ö†Ô∏è Service responding but with HTTP $http_code"
          else
            echo "‚ùå No response from service"
          fi

          sleep 2
        done

        echo "‚ùå Health check failed after $TIMEOUT attempts"
        echo "üîç Final container status and logs:"
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "echo 'Container status:' && sudo docker ps --filter name=$CONTAINER_NAME && echo 'Recent logs:' && sudo docker logs --tail=100 $CONTAINER_NAME"
        exit 1