name: Setup Let's Encrypt SSL Certificate (acme.sh with Webroot)
description: "Automatically provision SSL certificates from Let's Encrypt using HTTP-01 webroot validation (no nginx restart needed)"

inputs:
  host:
    description: "VPS hostname or IP"
    required: true
  user:
    description: "SSH username"
    required: true
  port:
    description: "SSH port"
    required: false
    default: "22"
  domain:
    description: "Primary domain for the certificate (e.g., example.com)"
    required: true
  additional_domains:
    description: "Comma-separated list of additional domains (e.g., www.example.com,api.example.com)"
    required: false
    default: ""
  email:
    description: "Email for Let's Encrypt registration and renewal notices"
    required: true
  webroot_path:
    description: "Path on VPS where acme challenge files will be placed (default: /var/www/acme-challenges)"
    required: false
    default: "/var/www/acme-challenges"
  certificates_dir:
    description: "Directory to store certificates on VPS (default: /etc/letsencrypt)"
    required: false
    default: "/etc/letsencrypt"
  force_renewal:
    description: "Force certificate renewal even if valid (set to 'true' to renew)"
    required: false
    default: "false"

outputs:
  cert_path:
    description: "Path to the certificate file"
    value: "${{ steps.cert-paths.outputs.cert_path }}"
  key_path:
    description: "Path to the private key file"
    value: "${{ steps.cert-paths.outputs.key_path }}"
  cert_dir:
    description: "Directory containing certificates"
    value: "${{ steps.cert-paths.outputs.cert_dir }}"

runs:
  using: "composite"
  steps:
    - name: Provision SSL Certificate (acme.sh with Webroot)
      shell: bash
      env:
        DOMAIN: "${{ inputs.domain }}"
        ADDITIONAL_DOMAINS: "${{ inputs.additional_domains }}"
        EMAIL: "${{ inputs.email }}"
        CERT_DIR: "${{ inputs.certificates_dir }}"
        WEBROOT_PATH: "${{ inputs.webroot_path }}"
        FORCE_RENEWAL: "${{ inputs.force_renewal }}"
      run: |
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "DOMAIN='$DOMAIN' ADDITIONAL_DOMAINS='$ADDITIONAL_DOMAINS' EMAIL='$EMAIL' CERT_DIR='$CERT_DIR' WEBROOT_PATH='$WEBROOT_PATH' FORCE_RENEWAL='$FORCE_RENEWAL' bash -s" <<-'EOF'
          set -euo pipefail

          echo "üîê Provisioning SSL certificate with Let's Encrypt (acme.sh with Webroot)"
          echo "   Primary Domain: $DOMAIN"
          if [ -n "$ADDITIONAL_DOMAINS" ]; then
            echo "   Additional Domains: $ADDITIONAL_DOMAINS"
          fi
          echo "   Email: $EMAIL"
          echo "   Certificate Directory: $CERT_DIR"
          echo "   Webroot Path: $WEBROOT_PATH"

          # Validate inputs
          if [ -z "$DOMAIN" ] || [ -z "$EMAIL" ]; then
            echo "‚ùå Missing required parameters: domain and email are required"
            exit 1
          fi

          # Create certificate directory
          if [ ! -d "$CERT_DIR" ]; then
            echo "üìÅ Creating certificate directory: $CERT_DIR"
            sudo mkdir -p "$CERT_DIR"
          fi

          # Create webroot directory for acme challenges
          echo "üìÅ Creating webroot directory: $WEBROOT_PATH"
          sudo mkdir -p "$WEBROOT_PATH/.well-known/acme-challenge"
          sudo chmod 777 "$WEBROOT_PATH"  # Allow acme.sh user to write challenge files
          sudo chmod 777 "$WEBROOT_PATH/.well-known" 2>/dev/null || true
          sudo chmod 777 "$WEBROOT_PATH/.well-known/acme-challenge" 2>/dev/null || true
          echo "‚úÖ Webroot directory created with write permissions"

          # Install acme.sh if not already installed
          ACME_DIR="$HOME/.acme.sh"
          if [ ! -d "$ACME_DIR" ]; then
            echo "üì• Installing acme.sh..."
            curl https://get.acme.sh | sh -s email="$EMAIL" > /dev/null 2>&1

            # Source the acme.sh installation
            source "$HOME/.bashrc" 2>/dev/null || true

            if [ ! -d "$ACME_DIR" ]; then
              echo "‚ùå Failed to install acme.sh"
              exit 1
            fi
            echo "‚úÖ acme.sh installed successfully"
          else
            echo "‚úÖ acme.sh already installed"
          fi

          # Get acme.sh binary path
          ACME_BIN="$ACME_DIR/acme.sh"
          if [ ! -f "$ACME_BIN" ]; then
            echo "‚ùå acme.sh binary not found at $ACME_BIN"
            exit 1
          fi

          # Build domain list for acme.sh
          DOMAIN_ARGS="-d $DOMAIN"
          if [ -n "$ADDITIONAL_DOMAINS" ]; then
            # Convert comma-separated list to multiple -d flags
            IFS=',' read -ra DOMAINS <<< "$ADDITIONAL_DOMAINS"
            for dom in "${DOMAINS[@]}"; do
              dom=$(echo "$dom" | xargs)  # Trim whitespace
              if [ -n "$dom" ]; then
                DOMAIN_ARGS="$DOMAIN_ARGS -d $dom"
              fi
            done
          fi

          # Check for existing certificate
          CERT_PATH="$CERT_DIR/live/$DOMAIN/fullchain.pem"
          KEY_PATH="$CERT_DIR/live/$DOMAIN/privkey.pem"
          FORCE_FLAG=""

          if [ "$FORCE_RENEWAL" = "true" ]; then
            echo "üîÑ Force renewal requested"
            FORCE_FLAG="--force"
          fi

          # Issue or renew certificate
          if [ -f "$CERT_PATH" ] && [ "$FORCE_RENEWAL" != "true" ]; then
            echo "‚ÑπÔ∏è  Certificate already exists for $DOMAIN"
            echo "   Path: $CERT_PATH"
            echo "üîÑ Attempting renewal if certificate is near expiration..."

            # acme.sh automatically handles renewal
            if $ACME_BIN --renew $FORCE_FLAG -d "$DOMAIN" 2>/dev/null || true; then
              echo "‚úÖ Certificate renewal checked"
            fi
          else
            # Request new certificate using webroot HTTP-01 challenge
            echo "üöÄ Requesting new certificate from Let's Encrypt..."
            echo "Setting up HTTP-01 validation (via webroot)..."
            ACME_LOG="$ACME_DIR/${DOMAIN}/${DOMAIN}.log"

            ACME_OUTPUT=$($ACME_BIN --issue \
              $FORCE_FLAG \
              --webroot "$WEBROOT_PATH" \
              --server letsencrypt \
              $DOMAIN_ARGS 2>&1 || true)

            echo "$ACME_OUTPUT" | tee /tmp/acme_debug.log

            # Check if certificate was successfully issued or already exists and is valid
            if echo "$ACME_OUTPUT" | grep -q "Cert success\|Domains not changed"; then
              echo "‚úÖ Certificate successfully provisioned"
            else
              echo "‚ùå Certificate provisioning failed"
              echo ""
              echo "=== acme.sh output ==="
              tail -50 /tmp/acme_debug.log || true
              echo "=== End acme.sh output ==="

              # Show acme.sh log if it exists
              if [ -f "$ACME_LOG" ]; then
                echo ""
                echo "=== acme.sh detailed log ==="
                tail -50 "$ACME_LOG" || true
                echo "=== End detailed log ==="
              fi

              # Troubleshooting suggestions
              echo ""
              echo "Troubleshooting:"
              echo "1. Verify nginx is configured to serve from $WEBROOT_PATH"
              echo "2. Check DNS resolution:"
              echo "   nslookup $DOMAIN"
              echo "3. Test webroot access:"
              echo "   curl -v http://$DOMAIN/.well-known/acme-challenge/test"
              echo "4. Check acme.sh log on VPS:"
              echo "   cat $ACME_LOG"

              exit 1
            fi
          fi

          # Install certificate to the target directory
          echo "üì¶ Installing certificate to $CERT_DIR..."
          LIVE_DIR="$CERT_DIR/live/$DOMAIN"
          if ! sudo mkdir -p "$LIVE_DIR"; then
            echo "‚ùå Failed to create certificate directory"
            exit 1
          fi

          # Install certificate - acme.sh will attempt to write to system directories
          # We need to allow acme.sh to write to these directories
          sudo chmod 755 "$LIVE_DIR" 2>/dev/null || true

          INSTALL_OUTPUT=$($ACME_BIN --install-cert -d "$DOMAIN" \
            --key-file "$KEY_PATH" \
            --fullchain-file "$CERT_PATH" \
            --reloadcmd "echo 'Certificate installed'" 2>&1 || true)

          echo "$INSTALL_OUTPUT"

          # The install-cert command may fail even if files are created correctly
          # Check if certificate files were actually created regardless of exit code
          if [ ! -f "$CERT_PATH" ] || [ ! -f "$KEY_PATH" ]; then
            echo "üìã Certificate files not found at target location, searching acme.sh storage..."

            # If files don't exist, try copying from acme.sh storage
            # acme.sh may store certificates in {domain}_ecc or {domain} directory
            ACME_CERT_DIR=""
            if [ -d "$ACME_DIR/${DOMAIN}_ecc" ]; then
              ACME_CERT_DIR="$ACME_DIR/${DOMAIN}_ecc"
            elif [ -d "$ACME_DIR/$DOMAIN" ]; then
              ACME_CERT_DIR="$ACME_DIR/$DOMAIN"
            fi

            if [ -n "$ACME_CERT_DIR" ]; then
              echo "üìÅ Found acme.sh storage at: $ACME_CERT_DIR"

              # List available files for debugging
              echo "   Available files:"
              ls -la "$ACME_CERT_DIR" 2>/dev/null | grep -E '\.(cer|pem|key)' | awk '{print "     " $NF}' || true

              # Find the actual certificate and key files
              # acme.sh stores: fullchain.cer (full chain), {domain}.cer (leaf), {domain}.key (private key)
              CERT_SRC=""
              KEY_SRC=""

              # Prefer fullchain.cer as it includes the full certificate chain
              if [ -f "$ACME_CERT_DIR/fullchain.cer" ]; then
                CERT_SRC="$ACME_CERT_DIR/fullchain.cer"
              elif [ -f "$ACME_CERT_DIR/$DOMAIN.cer" ]; then
                CERT_SRC="$ACME_CERT_DIR/$DOMAIN.cer"
              elif [ -f "$ACME_CERT_DIR/$DOMAIN.crt" ]; then
                CERT_SRC="$ACME_CERT_DIR/$DOMAIN.crt"
              fi

              # Find the key file
              if [ -f "$ACME_CERT_DIR/$DOMAIN.key" ]; then
                KEY_SRC="$ACME_CERT_DIR/$DOMAIN.key"
              fi

              if [ -n "$CERT_SRC" ] && [ -n "$KEY_SRC" ]; then
                echo "üìã Copying certificate from acme.sh storage..."
                echo "   Source cert: $CERT_SRC ‚Üí $CERT_PATH"
                echo "   Source key: $KEY_SRC ‚Üí $KEY_PATH"

                # Ensure parent directory exists and has correct permissions
                sudo mkdir -p "$(dirname "$CERT_PATH")" || true
                sudo chmod 755 "$(dirname "$CERT_PATH")" || true

                # Copy files with error checking
                if sudo cp "$CERT_SRC" "$CERT_PATH" 2>&1; then
                  echo "   ‚úÖ Certificate copied"
                else
                  echo "   ‚ùå Failed to copy certificate"
                  exit 1
                fi

                if sudo cp "$KEY_SRC" "$KEY_PATH" 2>&1; then
                  echo "   ‚úÖ Key copied"
                else
                  echo "   ‚ùå Failed to copy key"
                  exit 1
                fi
              else
                echo "‚ùå Could not find certificate files in acme.sh storage"
                echo "   Looking for fullchain.cer and {domain}.key"
                exit 1
              fi
            else
              echo "‚ùå Could not find acme.sh certificate directory"
              exit 1
            fi
          fi

          # Set proper permissions on copied files
          echo "üîê Setting certificate permissions..."
          sudo chown root:root "$CERT_PATH" "$KEY_PATH" 2>/dev/null || true
          sudo chmod 644 "$CERT_PATH" 2>/dev/null || true
          sudo chmod 600 "$KEY_PATH" 2>/dev/null || true

          # Verify certificate exists with retry logic (filesystem sync may take a moment)
          # Use sudo for verification since the directory is owned by root
          echo "‚úÖ Verifying certificate installation..."
          MAX_ATTEMPTS=5
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if sudo test -f "$CERT_PATH" && sudo test -f "$KEY_PATH"; then
              echo "   ‚úÖ Certificate files verified on attempt $ATTEMPT"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -le $MAX_ATTEMPTS ]; then
              echo "   ‚è≥ Waiting for filesystem sync (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
              sleep 1
            fi
          done

          if ! sudo test -f "$CERT_PATH" || ! sudo test -f "$KEY_PATH"; then
            echo "‚ùå Certificate files not found at expected paths after verification"
            echo "   Expected cert: $CERT_PATH"
            echo "   Expected key: $KEY_PATH"
            echo ""
            echo "Debugging info:"
            sudo ls -la "$(dirname "$CERT_PATH")" 2>&1 || true
            exit 1
          fi

          # Display certificate details
          echo ""
          echo "‚úÖ SSL Certificate Successfully Provisioned!"
          echo ""
          echo "üìã Certificate Details:"
          echo "   Cert Path: $CERT_PATH"
          echo "   Key Path: $KEY_PATH"

          # Show expiration date (use sudo since file is root-owned)
          EXPIRY=$(sudo openssl x509 -enddate -noout -in "$CERT_PATH" 2>/dev/null | cut -d= -f2 || echo "Unable to read")
          echo "   Expires: $EXPIRY"

          # Show all domains in certificate (use sudo since file is root-owned)
          echo "   Domains in Certificate:"
          sudo openssl x509 -noout -text -in "$CERT_PATH" 2>/dev/null | grep -A1 "Subject Alternative Name" | tail -1 | sed 's/DNS://g' | tr ',' '\n' | sed 's/^ */     - /' || true

          echo ""
          echo "üéâ Ready to use with nginx or other services!"
          echo "‚è∞ Auto-renewal enabled: certificates will renew automatically before expiration"
        EOF

    - name: Extract certificate paths
      id: cert-paths
      shell: bash
      run: |
        # Get paths from remote server and output them
        ssh -i ~/.ssh/id_rsa -p "${{ inputs.port }}" \
          -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o LogLevel=ERROR -T \
          "${{ inputs.user }}@${{ inputs.host }}" \
          "CERT_DIR='${{ inputs.certificates_dir }}' DOMAIN='${{ inputs.domain }}' bash -s" <<-'EOFCHECK'
          set -euo pipefail

          CERT_PATH="$CERT_DIR/live/$DOMAIN/fullchain.pem"
          KEY_PATH="$CERT_DIR/live/$DOMAIN/privkey.pem"
          CERT_LIVE_DIR="$CERT_DIR/live/$DOMAIN"

          # Use sudo test since files are root-owned
          if sudo test -f "$CERT_PATH" && sudo test -f "$KEY_PATH"; then
            echo "CERT_PATH=$CERT_PATH"
            echo "KEY_PATH=$KEY_PATH"
            echo "CERT_DIR=$CERT_LIVE_DIR"
            echo "‚úÖ Paths verified on remote server"
          else
            echo "‚ùå Certificate paths not found"
            echo "   Expected cert: $CERT_PATH"
            echo "   Expected key: $KEY_PATH"
            exit 1
          fi
        EOFCHECK

        # Export outputs to GitHub Actions
        echo "cert_path=${{ inputs.certificates_dir }}/live/${{ inputs.domain }}/fullchain.pem" >> $GITHUB_OUTPUT
        echo "key_path=${{ inputs.certificates_dir }}/live/${{ inputs.domain }}/privkey.pem" >> $GITHUB_OUTPUT
        echo "cert_dir=${{ inputs.certificates_dir }}/live/${{ inputs.domain }}" >> $GITHUB_OUTPUT
        echo "‚úÖ Paths exported for subsequent steps"

    - name: Restart nginx Docker container (if needed)
      shell: bash
      run: |
        echo "‚úÖ Certificate provisioning complete - no nginx restart needed!"
        echo "nginx continues serving from port 80 during validation"
